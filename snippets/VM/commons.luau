local task = task or require("@lune/task")
local RuntimeInitialize = require("@self/runtime")
local RuntimeInstance;
local rt, memory_at_0, cfns, INDIRECT_FUNCTIONS

--@@UTILS@@

do
    local NOW_CLOCK, NOW_TIME = os.clock(), os.time() * 1000
    local FILE_MAP = { {}, {} }
    local __TIMERS = {}
    local __EXIT_STATUS = nil
    local __ABORT_WASM = false
    local __NO_EXIT_RUNTIME = true
    local __RUNTIME_KEEPALIVE_COUNTER = 0

    local function proc_exit(code)
        __EXIT_STATUS = code
        if (not (__NO_EXIT_RUNTIME or __RUNTIME_KEEPALIVE_COUNTER > 0)) then
            __ABORT_WASM = true
        end

        assert(false, `ExitStatus: Program exited with code ${code}`)
    end

    local function fd_flush(file)
        local final = table.concat(file)
        local last = 1
        for index, data in string.gmatch(final, '()([^\n]*)\n') do
            last = index + #data
            print(data)
        end
        table.clear(file)
        file[1] = string.sub(final, last + 1)
    end

    local function fd_write(fd, list, count, ret_pointer)
        local file = FILE_MAP[fd]
        if not file then return 8 end
        local total = 0
        for pointer = list, list + (count - 1) * 8, 8 do
            local start = rt.load.i32(memory_at_0, pointer)
            local len = rt.load.i32(memory_at_0, pointer + 4)
            local read = rt.load.string(memory_at_0, start, len)
            table.insert(file, read)
            total = total + #read
        end
        rt.store.i32(memory_at_0, ret_pointer, total)
        fd_flush(file)
        return 0
    end

    local function _abort_js(reason)
        assert(false, `Aborted({reason})`)
    end

    local function __cxa_throw(ptr, type, destructor)
        local info = CException.new(ptr)
        assert(false, `exception occured in c: {info:_UndecoratedName()} ({info:vfptr()})`)
    end

    local function emscripten_resize_heap(_requestedSize)
        assert(false, "OOM")
    end

    local function emscripten_date_now()
        return NOW_TIME + (os.clock() - NOW_CLOCK) * 1000
    end

    local function _emscripten_throw_longjmp()
        return error(__LONGJMP_THROW_SIGN, 0)
    end

    local function _emscripten_runtime_keepalive_clear()
        __NO_EXIT_RUNTIME = false
        __RUNTIME_KEEPALIVE_COUNTER = 0
        return
    end

    local function _setitimer_js(which, timeoutMs)
        if (not task) then
            print("program is using _setitimer_js but task library not found, timers will NOT work.")
            return 0
        end

        if (__TIMERS[which]) then
            task.cancel(__TIMERS[which].thread)
            __TIMERS[which] = nil
        end
        if (not timeoutMs or timeoutMs == 0) then
            return 0
        end

        local thread = task.delay(function()
            __TIMERS[which] = nil
            if (__ABORT_WASM) then
                return
            end

            local success, err = pcall(function()
                cfns._emscripten_timeout(which, os.clock())
                if (__NO_EXIT_RUNTIME or __RUNTIME_KEEPALIVE_COUNTER > 0) then
                    return
                end

                local exit_success, exit_err = pcall(proc_exit, __EXIT_STATUS)
                if exit_success then
                    return
                end

                if (string.match(exit_err, "ExitStatus:") ~= nil or exit_err == "unwind") then
                    return __EXIT_STATUS
                end
                assert(false, exit_err)
            end)

            if (not success) then
                if (string.match(err, "ExitStatus:") ~= nil or err == "unwind") then
                    return
                end
                assert(false, err)
            end
        end, timeoutMs / 1000)

        __TIMERS[which] = { thread = thread, timeoutMs = timeoutMs }
        return 0
    end

    local function _localtime_js(timer, buf)
        local tdata = os.date("*t", rt.i64.into_u64(timer))
        
        --// https://en.cppreference.com/w/cpp/chrono/c/tm
        rt.store.i32(memory_at_0, buf + 0, tdata.sec) --// int tm_sec
        rt.store.i32(memory_at_0, buf + 4, tdata.min) --// int tm_min
        rt.store.i32(memory_at_0, buf + 8, tdata.hour) --// int tm_hour
        rt.store.i32(memory_at_0, buf + 12, tdata.day) --// int tm_mday
        rt.store.i32(memory_at_0, buf + 16, tdata.month - 1) --// int tm_mon
        rt.store.i32(memory_at_0, buf + 20, tdata.year - 1900) --// int tm_year
        rt.store.i32(memory_at_0, buf + 24, tdata.wday) --// int tm_wday
        rt.store.i32(memory_at_0, buf + 28, tdata.yday) --// int tm_yday
        rt.store.i32(memory_at_0, buf + 32, if tdata.isdst then 1 else 0) --// int tm_isdst
    end

    local function _gmtime_js(timer, buf)
        local tdata = os.date("!*t", rt.i64.into_u64(timer))

        --// https://en.cppreference.com/w/cpp/chrono/c/tm
        rt.store.i32(memory_at_0, buf + 0, tdata.sec) --// int tm_sec
        rt.store.i32(memory_at_0, buf + 4, tdata.min) --// int tm_min
        rt.store.i32(memory_at_0, buf + 8, tdata.hour) --// int tm_hour
        rt.store.i32(memory_at_0, buf + 12, tdata.day) --// int tm_mday
        rt.store.i32(memory_at_0, buf + 16, tdata.month - 1) --// int tm_mon
        rt.store.i32(memory_at_0, buf + 20, tdata.year - 1900) --// int tm_year
        rt.store.i32(memory_at_0, buf + 24, tdata.wday) --// int tm_wday
        rt.store.i32(memory_at_0, buf + 28, tdata.yday) --// int tm_yday
        rt.store.i32(memory_at_0, buf + 32, if tdata.isdst then 1 else 0) --// int tm_isdst
    end

    local function clock_time_get(clock_id: number, ignored_precision: boolean, ptime: number)
        if not (clock_id >= 0 and clock_id <= 3) then
            return 28
        end

        local time_now
        if clock_id == 0 then
            time_now = emscripten_date_now()
        elseif true then -- if nowIsMonotonic is 1
            time_now = os.clock()
        end

        local nsec = math.round(time_now * 1000 * 1000)
        rt.store.i64(memory_at_0, ptime, rt.i64.from_u64(nsec))
        return 0
    end

    RuntimeInstance = RuntimeInitialize({
        env = {
            func_list = {
                _tzset_js = stub("_tzset_js"),
                invoke_vii = invokeHandler(1),
                _abort_js = _abort_js,
                __cxa_throw = __cxa_throw,
                emscripten_date_now = emscripten_date_now,
                emscripten_resize_heap = emscripten_resize_heap,
                _emscripten_runtime_keepalive_clear = _emscripten_runtime_keepalive_clear,
                _emscripten_throw_longjmp = _emscripten_throw_longjmp,
                _setitimer_js = _setitimer_js,
                _localtime_js = _localtime_js,
                _gmtime_js = _gmtime_js,
            }
        },
        wasi_snapshot_preview1 = {
            func_list = {
                clock_time_get = clock_time_get,
                proc_exit = proc_exit,
                fd_write = fd_write,
            }
        }
    })
    rt, memory_at_0, cfns, INDIRECT_FUNCTIONS =
        RuntimeInstance.rt,
        RuntimeInstance.memory_list.memory,
        RuntimeInstance.func_list,
        RuntimeInstance.table_list.__indirect_function_table
end